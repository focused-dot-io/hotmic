<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Recording</title>
  <style>
    :root {
      --background-color: rgba(28, 28, 30, 0.85);
      --text-color: rgba(255, 255, 255, 0.9);
      --accent-color: #0071e3;
      --record-color: #ff3b30;
    }

    @media (prefers-color-scheme: light) {
      :root {
        --background-color: rgba(242, 242, 247, 0.85);
        --text-color: rgba(0, 0, 0, 0.9);
        --accent-color: #0071e3;
        --record-color: #ff3b30;
      }
    }

    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      -webkit-app-region: drag;
      user-select: none;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
      background-color: transparent;
    }

    .overlay-container {
      width: 280px;
      height: 280px;
      border-radius: 24px;
      background-color: var(--background-color);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      position: relative;
      overflow: hidden;
      transition: opacity 0.3s ease-in-out;
      opacity: 0;
    }

    .overlay-container.show {
      opacity: 1;
    }

    .recording-circle {
      width: 120px;
      height: 120px;
      background-color: var(--accent-color);
      border-radius: 50%;
      margin-bottom: 20px;
      position: relative;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .recording-circle.active {
      background-color: var(--record-color);
    }

    .status-text {
      color: var(--text-color);
      font-size: 18px;
      font-weight: 500;
      margin-top: 10px;
    }

    .timer {
      color: var(--text-color);
      font-size: 14px;
      margin-top: 5px;
      font-variant-numeric: tabular-nums;
    }

    .wave-container {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .wave {
      position: absolute;
      width: 150px;
      height: 150px;
      background-color: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      transform: scale(0);
      opacity: 0;
    }

    @keyframes wave-animation {
      0% {
        transform: scale(0);
        opacity: 0.7;
      }
      100% {
        transform: scale(1);
        opacity: 0;
      }
    }

    .mic-icon {
      width: 40px;
      height: 40px;
      fill: white;
      z-index: 2;
    }

    .close-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 24px;
      height: 24px;
      display: flex;
      justify-content: center;
      align-items: center;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.2);
      color: var(--text-color);
      cursor: pointer;
      -webkit-app-region: no-drag;
      opacity: 0.6;
      transition: opacity 0.2s;
    }

    .close-btn:hover {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="overlay-container">
    <div class="close-btn">âœ•</div>
    <div class="recording-circle">
      <div class="wave-container">
        <div class="wave" id="wave1"></div>
        <div class="wave" id="wave2"></div>
        <div class="wave" id="wave3"></div>
      </div>
      <svg class="mic-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
        <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
      </svg>
    </div>
    <div class="status-text">Recording...</div>
    <div class="timer">0:00</div>
  </div>

  <script>
    // DOM Elements
    const container = document.querySelector('.overlay-container');
    const recordingCircle = document.querySelector('.recording-circle');
    const closeBtn = document.querySelector('.close-btn');
    const wave1 = document.getElementById('wave1');
    const wave2 = document.getElementById('wave2');
    const wave3 = document.getElementById('wave3');
    const timerElement = document.querySelector('.timer');
    
    // State
    let isRecording = true; // Start as recording since overlay is shown during recording
    let startTime = null;
    let timerInterval = null;
    let waveInterval = null;
    console.log("Overlay window created - initial state: recording=true");
    
    // Handle ESC key to close window and cancel recording
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        console.log("ESC key pressed - canceling recording");
        // Cancel recording
        isRecording = false;
        window.electronAPI.updateRecordingState(false);
        
        // Clean up UI
        recordingCircle.classList.remove('active');
        clearInterval(waveInterval);
        clearInterval(timerInterval);
        
        // Fade out and close
        container.classList.remove('show');
        setTimeout(() => {
          console.log("ESC key handler - closing window");
          window.close();
        }, 300);
      }
    });
    
    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      // Show container with fade-in
      setTimeout(() => {
        container.classList.add('show');
      }, 100);
      
      // Set up audio visualization (simulate for now)
      setupWaveAnimation();
      
      // Start timer
      startTimer();
    });
    
    // Add event listeners
    closeBtn.addEventListener('click', () => {
      console.log("Close button clicked - canceling recording");
      // Cancel recording
      isRecording = false;
      window.electronAPI.updateRecordingState(false);
      
      // Clean up UI
      recordingCircle.classList.remove('active');
      clearInterval(waveInterval);
      clearInterval(timerInterval);
      
      // Hide window with fade effect before closing
      container.classList.remove('show');
      setTimeout(() => {
        console.log("Close button handler - closing window");
        window.close();
      }, 300);
    });
    
    // Also handle window being closed or unloaded
    window.addEventListener('beforeunload', () => {
      // This ensures the main process knows recording has stopped
      window.electronAPI.updateRecordingState(false);
    });
    
    // Handle recording toggle from main process
    window.electronAPI.onToggleRecording(() => {
      console.log(`Overlay received toggle-recording. Current state: ${isRecording}`);
      
      // Toggle state
      isRecording = !isRecording;
      console.log(`Overlay new recording state: ${isRecording}`);
      
      if (isRecording) {
        console.log("Overlay starting recording visualization");
        recordingCircle.classList.add('active');
        setupWaveAnimation();
        startTimer();
      } else {
        console.log("Overlay stopping recording visualization");
        recordingCircle.classList.remove('active');
        clearInterval(waveInterval);
        clearInterval(timerInterval);
        
        // Fade out and close the window
        console.log("Overlay fading out");
        container.classList.remove('show');
        
        // Close the window after animation
        setTimeout(() => {
          console.log("Overlay closing window");
          window.close();
        }, 300);
      }
    });
    
    // Handle audio level updates from main process
    const removeAudioLevelListener = window.electronAPI.onAudioLevel((level) => {
      // Use audio level to adjust wave animations
      triggerWaveWithLevel(level);
    });
    
    // Clean up listeners when window closes
    window.addEventListener('beforeunload', () => {
      if (removeAudioLevelListener) removeAudioLevelListener();
    });
    
    // Functions
    function setupWaveAnimation() {
      // Clear any existing interval
      if (waveInterval) clearInterval(waveInterval);
      
      // Set recording circle to active
      recordingCircle.classList.add('active');
      
      // Initialize wave animation with a subtle background pulse
      let counter = 0;
      const createWave = () => {
        // Choose which wave element to animate
        const wave = counter % 3 === 0 ? wave1 : counter % 3 === 1 ? wave2 : wave3;
        
        // Reset animation
        wave.style.animation = 'none';
        void wave.offsetWidth; // Trigger reflow
        
        // Apply a subtle background pulse
        const duration = 1.5;
        wave.style.animation = `wave-animation ${duration}s ease-out`;
        wave.style.transform = `scale(0.5)`;
        
        counter++;
      };
      
      // Start initial wave
      createWave();
      
      // Set interval for continuous background waves (slower for subtle effect)
      waveInterval = setInterval(createWave, 1500);
    }
    
    // Last level timestamp to prevent too many waves
    let lastWaveTime = 0;
    
    function triggerWaveWithLevel(level) {
      // Don't trigger waves too often (throttle to 100ms)
      const now = Date.now();
      if (now - lastWaveTime < 100) return;
      lastWaveTime = now;
      
      // Pick a wave element (cycle through them)
      const waveIndex = Math.floor(Math.random() * 3);
      const wave = waveIndex === 0 ? wave1 : waveIndex === 1 ? wave2 : wave3;
      
      // Reset animation
      wave.style.animation = 'none';
      void wave.offsetWidth; // Trigger reflow
      
      // Map level (0-1) to scale (0.5-1.0)
      const strength = 0.5 + (level * 0.5);
      
      // Map level to animation speed (1.5-0.7s - higher levels are faster)
      const duration = 1.5 - (level * 0.8);
      
      // Apply animation
      wave.style.animation = `wave-animation ${duration}s ease-out`;
      wave.style.transform = `scale(${strength})`;
    }
    
    function startTimer() {
      // Clear any existing interval
      if (timerInterval) clearInterval(timerInterval);
      
      // Initialize timer
      startTime = Date.now();
      updateTimer();
      
      // Update timer every second
      timerInterval = setInterval(updateTimer, 1000);
    }
    
    function updateTimer() {
      const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
      const minutes = Math.floor(elapsedSeconds / 60);
      const seconds = elapsedSeconds % 60;
      timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      
      // Auto close after 30 seconds
      if (elapsedSeconds >= 30) {
        window.electronAPI.updateRecordingState(false);
        window.close();
      }
    }
  </script>
</body>
</html>