<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>HotMic Settings</title>
  <style>
    :root {
      color-scheme: light dark;

      /* System Colors */
      --background: var(--apple-system-background, #ffffff);
      --text: var(--apple-system-text, #000000);
      --secondary-text: var(--apple-system-secondary-label, #666666);
      --control-background: rgba(0, 0, 0, 0.1);
      --control-border: rgba(0, 0, 0, 0.1);
      --accent: #007AFF;
      --separator: rgba(0, 0, 0, 0.1);

      /* Custom Colors - Light Mode */
      --form-group-background: rgba(0, 0, 0, 0.03);
      --input-background: rgba(0, 0, 0, 0.1);
      --button-background: rgba(255, 255, 255, 0.8);
      --button-hover: rgba(0, 0, 0, 0.05);
      --scrollbar-thumb: rgba(0, 0, 0, 0.2);
      --scrollbar-thumb-hover: rgba(0, 0, 0, 0.3);

      /* Spacing */
      --spacing-xs: 4px;
      --spacing-sm: 8px;
      --spacing-md: 16px;
      --spacing-lg: 24px;

      /* Radius */
      --radius-sm: 4px;
      --radius-md: 6px;
      --radius-lg: 8px;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        /* System Colors - Dark Mode */
        --background: #1e1e1e;
        --text: #ffffff;
        --secondary-text: #999999;
        --control-background: rgba(255, 255, 255, 0.1);
        --control-border: rgba(255, 255, 255, 0.1);
        --separator: rgba(255, 255, 255, 0.1);

        /* Custom Colors - Dark Mode */
        --form-group-background: rgba(255, 255, 255, 0.05);
        --input-background: rgba(0, 0, 0, 0.3);
        --button-background: rgba(255, 255, 255, 0.1);
        --button-hover: rgba(255, 255, 255, 0.15);
        --scrollbar-thumb: rgba(255, 255, 255, 0.2);
        --scrollbar-thumb-hover: rgba(255, 255, 255, 0.3);
      }
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: var(--background);
      color: var(--text);
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
      min-width: 700px;
      min-height: 500px;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    /* Tab Navigation */
    .tab-nav {
      display: flex;
      padding: var(--spacing-lg) var(--spacing-md) 0;
      gap: var(--spacing-xs);
      background: var(--tab-background);
      border-bottom: 1px solid var(--separator);
      justify-content: center;
    }

    .tab-button {
      padding: var(--spacing-sm) var(--spacing-md);
      background: var(--tab-background);
      border: 1px solid var(--control-border);
      border-bottom: none;
      border-radius: var(--radius-sm) var(--radius-sm) 0 0;
      color: var(--secondary-text);
      font-size: 13px;
      cursor: pointer;
      position: relative;
      bottom: -1px;
      transition: all 0.2s ease;
    }

    .tab-button:hover {
      color: var(--text);
      background: color-mix(in srgb, var(--background) 98%, var(--text));
    }

    .tab-button.active {
      background: var(--background);
      border-bottom: 1px solid var(--background);
      color: var(--text);
      font-weight: 500;
      box-shadow: 0 -2px 0 var(--accent);
    }

    /* Tab Content */
    .tab-content {
      flex: 1;
      padding: var(--spacing-lg);
      overflow-y: auto;
    }

    .tab-panel {
      display: none;
      max-width: 650px;
      margin: 0 auto;
    }

    .tab-panel.active {
      display: block;
    }

    h1,
    h2,
    h3 {
      font-weight: 500;
      margin: 0 0 var(--spacing-md) 0;
      color: var(--text);
    }

    .form-group {
      margin-bottom: var(--spacing-lg);
      padding: var(--spacing-md);
      background: var(--form-group-background);
      border: 1px solid var(--control-border);
      border-radius: var(--radius-md);
    }

    label {
      display: block;
      margin-bottom: var(--spacing-xs);
      color: var(--text);
      font-weight: 500;
    }

    input[type="text"],
    input[type="password"],
    textarea {
      width: 100%;
      padding: var(--spacing-sm);
      margin-bottom: var(--spacing-sm);
      border: 1px solid var(--control-border);
      border-radius: var(--radius-sm);
      background: var(--input-background);
      color: var(--text);
      font-family: inherit;
      font-size: 13px;
      box-sizing: border-box;
    }

    input[type="text"]:focus,
    input[type="password"]:focus,
    textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent) 30%, transparent);
    }

    button {
      padding: var(--spacing-sm) var(--spacing-md);
      background: var(--button-background);
      border: 1px solid var(--control-border);
      border-radius: var(--radius-sm);
      color: var(--text);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
    }

    button:hover {
      background: var(--button-hover);
    }

    button.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
      font-weight: 600;
    }

    button.primary:hover {
      filter: brightness(1.1);
    }

    .status {
      margin-top: var(--spacing-xs);
      font-size: 12px;
    }

    .status.success {
      color: var(--system-green);
    }

    .status.error {
      color: var(--system-red);
    }

    .checkbox-group {
      margin: var(--spacing-sm) 0;
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
    }

    input[type="checkbox"] {
      appearance: none;
      width: 16px;
      height: 16px;
      border: 1px solid var(--control-border);
      border-radius: 4px;
      background: var(--input-background);
      cursor: pointer;
      position: relative;
      vertical-align: middle;
    }

    input[type="checkbox"]:checked {
      background: var(--accent);
      border-color: var(--accent);
    }

    input[type="checkbox"]:checked::after {
      content: '';
      position: absolute;
      left: 5px;
      top: 2px;
      width: 4px;
      height: 8px;
      border: solid white;
      border-width: 0 2px 2px 0;
      transform: rotate(45deg);
    }

    input[type="checkbox"]:hover {
      border-color: var(--accent);
    }

    #promptSection {
      margin-top: var(--spacing-md);
      transition: opacity 0.3s;
    }

    #promptSection.disabled {
      opacity: 0.5;
      pointer-events: none;
    }

    /* History Section */
    .history-item {
      margin: var(--spacing-sm) 0;
      padding: var(--spacing-md);
      background: var(--control-background);
      border: 1px solid var(--control-border);
      border-radius: var(--radius-md);
    }

    .history-item .timestamp {
      font-size: 12px;
      color: var(--secondary-text);
      margin-bottom: var(--spacing-xs);
    }

    .history-item .transcript {
      margin: var(--spacing-xs) 0;
      white-space: pre-wrap;
      color: var(--text);
    }

    .history-item .raw-transcript {
      color: var(--secondary-text);
      font-size: 0.9em;
      margin-top: var(--spacing-sm);
      padding-top: var(--spacing-sm);
      border-top: 1px solid var(--separator);
    }

    .history-item button {
      margin-right: var(--spacing-xs);
      padding: 2px var(--spacing-sm);
      font-size: 12px;
    }

    footer {
      margin-top: var(--spacing-lg);
      padding-top: var(--spacing-md);
      border-top: 1px solid var(--separator);
      text-align: center;
      color: var(--secondary-text);
      font-size: 12px;
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
      border-radius: var(--radius-lg);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--scrollbar-thumb);
      border: 2px solid transparent;
      background-clip: padding-box;
      border-radius: var(--radius-lg);
      min-height: 40px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--scrollbar-thumb-hover);
    }

    /* Shortcut display */
    .shortcut-display {
      display: inline-block;
      padding: var(--spacing-xs) var(--spacing-sm);
      background: var(--input-background);
      border: 1px solid var(--control-border);
      border-radius: var(--radius-sm);
      font-family: monospace;
      margin: var(--spacing-xs) 0;
    }

    .shortcut-controls {
      display: flex;
      gap: var(--spacing-sm);
      align-items: center;
      margin-top: var(--spacing-sm);
    }

    #shortcutListener {
      margin-top: var(--spacing-sm);
    }

    /* History Layout */
    .history-layout {
      display: flex;
      gap: var(--spacing-md);
      height: calc(100vh - 150px);
      margin: calc(-1 * var(--spacing-lg));
    }

    .history-sidebar {
      width: 300px;
      border-right: 1px solid var(--separator);
      overflow-y: auto;
      padding: 0;
    }

    .history-content {
      flex: 1;
      padding: var(--spacing-md);
      overflow-y: auto;
    }

    .history-list {
      display: flex;
      flex-direction: column;
    }

    .history-item {
      padding: var(--spacing-md);
      background: var(--form-group-background);
      border: 1px solid var(--control-border);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .history-item:hover {
      background: color-mix(in srgb, var(--form-group-background) 80%, var(--text));
    }

    .history-item.selected {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .history-item .timestamp {
      font-size: 12px;
      color: var(--secondary-text);
      margin-bottom: var(--spacing-xs);
    }

    .history-item.selected .timestamp {
      color: rgba(255, 255, 255, 0.8);
    }

    .history-item .preview {
      font-size: 13px;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
    }

    .transcript-detail {
      height: 100%;
    }

    .transcript-detail .placeholder-message {
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--secondary-text);
      font-size: 14px;
    }

    .transcript-detail .content {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-md);
    }

    .transcript-section {
      background: var(--form-group-background);
      border: 1px solid var(--control-border);
      border-radius: var(--radius-md);
      padding: var(--spacing-md);
    }

    .transcript-section h3 {
      margin-bottom: var(--spacing-sm);
      color: var(--text);
      font-size: 14px;
      font-weight: 500;
    }

    .transcript-section .text {
      white-space: pre-wrap;
      font-size: 13px;
      line-height: 1.5;
    }

    .transcript-actions {
      display: flex;
      gap: var(--spacing-xs);
      margin-top: var(--spacing-sm);
    }

    .history-sidebar .history-item {
      padding: var(--spacing-md);
      background: transparent;
      border: none;
      border-bottom: 1px solid var(--separator);
      border-radius: 0;
      cursor: pointer;
      transition: all 0.2s ease;
      margin: 0;
    }

    .history-sidebar .history-item:last-child {
      border-bottom: none;
    }

    .history-sidebar .history-item:hover {
      background: color-mix(in srgb, var(--background) 95%, var(--text));
    }

    .history-sidebar .history-item.selected {
      background: color-mix(in srgb, var(--accent) 10%, transparent);
      color: var(--text);
      border-color: var(--separator);
    }

    .history-sidebar .history-item.selected .timestamp {
      color: var(--secondary-text);
    }

    /* Main content transcript sections retain bubble style */
    .transcript-section {
      background: var(--form-group-background);
      border: 1px solid var(--control-border);
      border-radius: var(--radius-md);
      padding: var(--spacing-md);
    }

    /* Button interaction styles */
    button:active {
      transform: scale(0.96);
    }

    .button-success {
      position: relative;
      overflow: hidden;
    }

    .button-success::after {
      content: '✓';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .button-success.copied::after {
      opacity: 1;
    }

    .button-success.copied {
      background: color-mix(in srgb, var(--accent) 20%, var(--button-background));
      transition: background 0.2s ease;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      pointer-events: none;
    }

    button.danger {
      background: #ff3b30;
      border-color: #ff3b30;
      color: white;
      font-weight: 600;
    }

    button.danger:hover {
      filter: brightness(1.1);
    }
  </style>
</head>

<body>
  <div class="container">
    <!-- Tab Navigation -->
    <nav class="tab-nav">
      <button class="tab-button active" data-tab="general">General</button>
      <button class="tab-button" data-tab="api-providers">API Providers</button>
      <button class="tab-button" data-tab="transcription">Transcription</button>
      <button class="tab-button" data-tab="history">History</button>
    </nav>

    <!-- Tab Content -->
    <div class="tab-content">
      <!-- General Tab -->
      <div class="tab-panel active" id="general-panel">
        <div class="form-group">
          <h3>Global Shortcut</h3>
          <div>
            Current: <span id="currentShortcut" class="shortcut-display"></span>
          </div>
          <div id="shortcutListener" style="display: none;">
            <p>Press the key combination you want to use:</p>
            <span id="newShortcut" class="shortcut-display">Listening...</span>
          </div>
          <div class="shortcut-controls">
            <button id="editShortcut">Change Shortcut</button>
            <button id="saveShortcut" style="display: none;">Save</button>
            <button id="cancelShortcut" style="display: none;">Cancel</button>
          </div>
          <div id="shortcutStatus" class="status"></div>
        </div>

        <div class="form-group">
          <h3>How to Use</h3>
          <ol style="margin: 0; padding-left: var(--spacing-lg);">
            <li>Press the global shortcut to show the recording overlay</li>
            <li>Speak into your microphone</li>
            <li>Press the shortcut again to stop recording</li>
            <li>Wait for transcription</li>
            <li>The transcribed text will be copied to your clipboard</li>
            <li>If post-processing is enabled, you'll get the formatted text; otherwise, you'll get the raw transcript</li>
          </ol>
          <p style="margin-top: var(--spacing-sm); color: var(--secondary-text); font-size: 13px;"><strong>Note:</strong> An API key is required for the application to work. Post-processing (text formatting) is optional and can be enabled or disabled.</p>
        </div>
      </div>

      <!-- API Providers Tab -->
      <div class="tab-panel" id="api-providers-panel">
        <div class="form-group">
          <h3>Speech-to-Text Provider</h3>
          <div class="provider-select" style="margin-bottom: var(--spacing-md);">
            <label for="apiProvider">Active Provider:</label>
            <select id="apiProvider" style="width: 100%; padding: var(--spacing-sm); background: var(--input-background); border: 1px solid var(--control-border); border-radius: var(--radius-sm); color: var(--text);">
              <option value="groq">Groq API</option>
              <option value="openai">OpenAI API</option>
            </select>
          </div>
        </div>

        <!-- Groq API Configuration -->
        <div id="groqApiSection" class="form-group">
          <h3>Groq API Configuration</h3>
          <div style="margin-bottom: var(--spacing-md);">
            <label for="groqBaseUrl">API Base URL:</label>
            <input type="text" id="groqBaseUrl" placeholder="https://api.groq.com/openai/v1" value="https://api.groq.com/openai/v1">
          </div>
          <div style="margin-bottom: var(--spacing-md);">
            <label for="apiKey">API Key:</label>
            <div style="display: flex; gap: var(--spacing-sm);">
              <input type="password" id="apiKey" placeholder="Enter your Groq API key">
              <button id="saveApiKey" class="primary">Save</button>
            </div>
          </div>
          <div style="margin-bottom: var(--spacing-md);">
            <label for="groqModel">Model:</label>
            <select id="groqModel" style="width: 100%; padding: var(--spacing-sm); background: var(--input-background); border: 1px solid var(--control-border); border-radius: var(--radius-sm); color: var(--text);">
              <option value="whisper-large-v3">whisper-large-v3</option>
            </select>
          </div>
          <div class="api-note" style="margin: var(--spacing-sm) 0; color: var(--secondary-text); font-size: 13px;">
            <strong>Note:</strong> The Groq API key is required for Groq API transcriptions.
          </div>
          <div id="apiKeyStatus" class="status"></div>
        </div>

        <!-- OpenAI API Configuration -->
        <div id="openaiApiSection" class="form-group" style="display: none;">
          <h3>OpenAI API Configuration</h3>
          <div style="margin-bottom: var(--spacing-md);">
            <label for="openaiBaseUrl">API Base URL:</label>
            <input type="text" id="openaiBaseUrl" placeholder="https://api.openai.com/v1" value="https://api.openai.com/v1">
          </div>
          <div style="margin-bottom: var(--spacing-md);">
            <label for="openaiApiKey">API Key:</label>
            <div style="display: flex; gap: var(--spacing-sm);">
              <input type="password" id="openaiApiKey" placeholder="Enter your OpenAI API key">
              <button id="saveOpenaiApiKey" class="primary">Save</button>
            </div>
          </div>
          <div style="margin-bottom: var(--spacing-md);">
            <label for="openaiModel">Model:</label>
            <select id="openaiModel" style="width: 100%; padding: var(--spacing-sm); background: var(--input-background); border: 1px solid var(--control-border); border-radius: var(--radius-sm); color: var(--text);">
              <option value="gpt-4o-transcribe">gpt-4o-transcribe</option>
              <option value="gpt-4o-mini-transcribe">gpt-4o-mini-transcribe</option>
              <option value="whisper-large-v2">whisper-large-v2</option>
              <option value="whisper-large-v3">whisper-large-v3</option>
            </select>
          </div>
          <div class="api-note" style="margin: var(--spacing-sm) 0; color: var(--secondary-text); font-size: 13px;">
            <strong>Note:</strong> The OpenAI API key is required for OpenAI API transcriptions.
          </div>
          <div id="openaiApiKeyStatus" class="status"></div>
        </div>
      </div>

      <!-- Transcription Tab -->
      <div class="tab-panel" id="transcription-panel">
        <div class="form-group">
          <h3>Post-Processing</h3>
          <div class="checkbox-group">
            <input type="checkbox" id="enablePostProcessing">
            <label for="enablePostProcessing">Enable post-processing with LLM</label>
          </div>
          <div class="description-box" style="margin: var(--spacing-sm) 0; padding: var(--spacing-sm); background: rgba(0, 0, 0, 0.05); border-radius: var(--radius-sm); font-size: 13px;">
            <strong>What is post-processing?</strong>
            <p>Post-processing is an optional feature that enhances your transcription. The basic transcription already provides the raw text from the Whisper model.</p>
            <p>When post-processing is enabled, your raw transcript is sent to the selected provider's LLM with the prompt below to format and enhance it. The processed version is what gets copied to your clipboard, not the raw transcript.</p>
            <p>To get the raw transcript instead, either disable post-processing or modify the prompt to: "Return the transcript exactly as provided with no changes."</p>
          </div>
          <div id="promptSection">
            <label for="prompt">Processing Prompt:</label>
            <textarea id="prompt" rows="4" style="width: 100%; margin-top: var(--spacing-xs); resize: vertical;"
              placeholder="Enter your prompt for post-processing transcripts..."></textarea>
            <button id="resetPrompt" style="margin-top: var(--spacing-xs);">Reset to Default</button>
            <div id="promptStatus" class="status"></div>
          </div>
        </div>
      </div>

      <!-- History Tab -->
      <div class="tab-panel" id="history-panel">
        <div class="history-layout">
          <div class="history-sidebar">
            <div class="history-controls" style="padding: var(--spacing-md); display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--separator);">
              <div class="checkbox-group">
                <input type="checkbox" id="historyEnabled" checked>
                <label for="historyEnabled">Enable History</label>
              </div>
              <button id="clearHistory" class="danger">Clear History</button>
            </div>
            <div class="history-encryption-status" style="padding: var(--spacing-sm) var(--spacing-md); font-size: 12px; color: var(--secondary-text); display: flex; align-items: center; gap: var(--spacing-xs); border-bottom: 1px solid var(--separator);">
              <span id="encryptionStatus"></span>
            </div>
            <div class="history-list" id="historyList">
              <!-- History items will be inserted here -->
            </div>
          </div>
          <div class="history-content">
            <div id="selectedTranscript" class="transcript-detail">
              <div class="placeholder-message">Select a transcript to view details</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <footer>
      <p>HotMic v0.0.2</p>
    </footer>
  </div>

  <script>
    /**
     * HotMic Settings
     */

    // Application references
    const elements = {
      // API Provider elements
      apiProvider: document.getElementById('apiProvider'),
      groqApiSection: document.getElementById('groqApiSection'),
      openaiApiSection: document.getElementById('openaiApiSection'),

      // Groq API elements
      groqBaseUrl: document.getElementById('groqBaseUrl'),
      groqModel: document.getElementById('groqModel'),
      apiKeyInput: document.getElementById('apiKey'),
      saveApiKeyBtn: document.getElementById('saveApiKey'),
      apiKeyStatus: document.getElementById('apiKeyStatus'),

      // OpenAI API elements
      openaiBaseUrl: document.getElementById('openaiBaseUrl'),
      openaiModel: document.getElementById('openaiModel'),
      openaiApiKeyInput: document.getElementById('openaiApiKey'),
      saveOpenaiApiKeyBtn: document.getElementById('saveOpenaiApiKey'),
      openaiApiKeyStatus: document.getElementById('openaiApiKeyStatus'),

      // Shortcut elements
      currentShortcut: document.getElementById('currentShortcut'),
      editShortcut: document.getElementById('editShortcut'),
      shortcutListener: document.getElementById('shortcutListener'),
      newShortcut: document.getElementById('newShortcut'),
      saveShortcut: document.getElementById('saveShortcut'),
      cancelShortcut: document.getElementById('cancelShortcut'),
      shortcutStatus: document.getElementById('shortcutStatus'),

      // Post-processing elements
      enablePostProcessing: document.getElementById('enablePostProcessing'),
      prompt: document.getElementById('prompt'),
      resetPrompt: document.getElementById('resetPrompt'),
      promptStatus: document.getElementById('promptStatus'),

      // History elements
      historyEnabled: document.getElementById('historyEnabled'),
      clearHistory: document.getElementById('clearHistory'),
      encryptionStatus: document.getElementById('encryptionStatus'),
      historyList: document.getElementById('historyList')
    };

    // Application state
    const state = {
      keys: new Set(),
      listeningForShortcut: false,
      apiProvider: 'groq' // Default provider
    };

    /**
     * Settings Management
     */

    // Load settings from store
    async function loadSettings() {
      try {
        await loadApiProvider();
        await loadApiKey();
        await loadOpenaiApiKey();
        await loadBaseUrls();
        await loadModels();
        await loadShortcut();
        await loadPromptSettings();
        await loadHistorySettings();
        await loadHistory();
      } catch (error) {
        console.error('Error loading settings:', error);
      }
    }

    // Load API provider from store
    async function loadApiProvider() {
      const provider = await window.api.getApiProvider();
      if (provider) {
        elements.apiProvider.value = provider;
        state.apiProvider = provider;
        updateApiSectionVisibility();
      }
    }

    // Load base URLs from store
    async function loadBaseUrls() {
      const groqBaseUrl = await window.api.getGroqBaseUrl();
      if (groqBaseUrl) {
        elements.groqBaseUrl.value = groqBaseUrl;
      }

      const openaiBaseUrl = await window.api.getOpenaiBaseUrl();
      if (openaiBaseUrl) {
        elements.openaiBaseUrl.value = openaiBaseUrl;
      }

    }

    // Load models from store
    async function loadModels() {
      try {
        const groqModel = await window.api.getGroqModel();
        if (groqModel) {
          elements.groqModel.value = groqModel;
        }

        const openaiModel = await window.api.getOpenaiModel();
        if (openaiModel) {
          elements.openaiModel.value = openaiModel;
        }
      } catch (error) {
        console.error('Error loading models:', error);
      }
    }

    // Load API key from store
    async function loadApiKey() {
      const apiKey = await window.api.getApiKey();
      if (apiKey) {
        elements.apiKeyInput.value = apiKey;
        showStatus(elements.apiKeyStatus, 'API key is set', 'success');
      }
    }

    // Load OpenAI API key from store
    async function loadOpenaiApiKey() {
      const apiKey = await window.api.getOpenaiApiKey();
      if (apiKey) {
        elements.openaiApiKeyInput.value = apiKey;
        showStatus(elements.openaiApiKeyStatus, 'API key is set', 'success');
      }
    }

    // Update API section visibility based on selected provider
    function updateApiSectionVisibility() {
      // Hide all sections first
      elements.groqApiSection.style.display = 'none';
      elements.openaiApiSection.style.display = 'none';

      // Show selected provider section
      if (state.apiProvider === 'groq') {
        elements.groqApiSection.style.display = 'block';
      } else if (state.apiProvider === 'openai') {
        elements.openaiApiSection.style.display = 'block';
      }
    }

    // Load shortcut from store
    async function loadShortcut() {
      const shortcut = await window.api.getShortcut();
      elements.currentShortcut.textContent = shortcut;
    }

    // Load prompt settings
    async function loadPromptSettings() {
      const settings = await window.api.getPromptSettings();
      elements.enablePostProcessing.checked = settings.enabled;
      elements.prompt.value = settings.prompt;
      updatePromptSectionState();
    }

    // Update prompt section state based on checkbox
    function updatePromptSectionState() {
      const promptSection = document.getElementById('promptSection');
      promptSection.classList.toggle('disabled', !elements.enablePostProcessing.checked);
    }

    // Reset prompt to default
    async function resetPrompt() {
      const defaultPrompt = 'Please format this transcript as a professional email with a greeting and sign-off. Make it concise and clear while maintaining the key information.';
      elements.prompt.value = defaultPrompt;
      await savePromptSettings();
    }

    // Save API key to store
    async function saveApiKey() {
      const apiKey = elements.apiKeyInput.value.trim();
      const baseUrl = elements.groqBaseUrl.value.trim();
      const model = elements.groqModel.value;

      try {
        await window.api.setApiKey(apiKey);
        await window.api.setGroqBaseUrl(baseUrl);
        await window.api.setGroqModel(model);

        if (apiKey) {
          showStatus(elements.apiKeyStatus, 'Settings saved successfully', 'success');
        } else {
          showStatus(elements.apiKeyStatus, 'API key removed', 'success');
        }
      } catch (error) {
        showStatus(elements.apiKeyStatus, `Error saving settings: ${error.message}`, 'error');
      }
    }

    // Save OpenAI API key to store
    async function saveOpenaiApiKey() {
      const apiKey = elements.openaiApiKeyInput.value.trim();
      const baseUrl = elements.openaiBaseUrl.value.trim();
      const model = elements.openaiModel.value;

      try {
        await window.api.setOpenaiApiKey(apiKey);
        await window.api.setOpenaiBaseUrl(baseUrl);
        await window.api.setOpenaiModel(model);

        if (apiKey) {
          showStatus(elements.openaiApiKeyStatus, 'Settings saved successfully', 'success');
        } else {
          showStatus(elements.openaiApiKeyStatus, 'API key removed', 'success');
        }
      } catch (error) {
        showStatus(elements.openaiApiKeyStatus, `Error saving settings: ${error.message}`, 'error');
      }
    }

    /**
     * Shortcut Management
     */

    // Start listening for shortcut keys
    function startShortcutListener() {
      elements.shortcutListener.style.display = 'block';
      elements.editShortcut.style.display = 'none';
      elements.saveShortcut.style.display = 'inline-block';
      elements.cancelShortcut.style.display = 'inline-block';
      state.listeningForShortcut = true;
      state.keys.clear();
      elements.newShortcut.textContent = 'Listening...';
      elements.saveShortcut.disabled = true;
    }

    // Cancel shortcut change
    function cancelShortcutChange() {
      elements.shortcutListener.style.display = 'none';
      elements.editShortcut.style.display = 'inline-block';
      elements.saveShortcut.style.display = 'none';
      elements.cancelShortcut.style.display = 'none';
      state.listeningForShortcut = false;
    }

    // Save new shortcut
    async function saveShortcut() {
      const shortcutString = elements.newShortcut.textContent;

      try {
        const success = await window.api.setShortcut(shortcutString);

        if (success) {
          elements.currentShortcut.textContent = shortcutString;
          showStatus(elements.shortcutStatus, 'Shortcut saved successfully', 'success');
        } else {
          showStatus(elements.shortcutStatus, 'Failed to register shortcut', 'error');
        }
      } catch (error) {
        showStatus(elements.shortcutStatus, `Error saving shortcut: ${error.message}`, 'error');
      }

      // Reset UI
      cancelShortcutChange();
    }

    // Handle keydown events for shortcut recording
    function handleKeyDown(event) {
      if (!state.listeningForShortcut) return;

      event.preventDefault();

      // Get the key
      let key = event.key;

      // Handle escape key to cancel
      if (key === 'Escape') {
        cancelShortcutChange();
        return;
      }

      // Convert special keys to Electron format
      if (key === ' ') key = 'Space';
      if (key === 'Control') key = 'Ctrl';

      // Capitalize first letter
      key = key.charAt(0).toUpperCase() + key.slice(1);

      // Add to key set
      state.keys.add(key);

      // Update display
      updateShortcutDisplay();
    }

    // Handle keyup events for shortcut recording
    function handleKeyUp(event) {
      if (!state.listeningForShortcut) return;

      // Enable save button if we have valid keys
      if (state.keys.size > 0) {
        elements.saveShortcut.disabled = false;
      }
    }

    // Update shortcut display
    function updateShortcutDisplay() {
      if (state.keys.size === 0) {
        elements.newShortcut.textContent = 'Listening...';
        return;
      }

      // Check for modifiers
      const hasCtrl = state.keys.has('Ctrl');
      const hasAlt = state.keys.has('Alt');
      const hasShift = state.keys.has('Shift');
      const hasMeta = state.keys.has('Meta') || state.keys.has('Command');

      // Build shortcut string
      let shortcutParts = [];

      // Add modifiers first
      if (hasMeta) shortcutParts.push('Command');
      if (hasCtrl) shortcutParts.push('Ctrl');
      if (hasAlt) shortcutParts.push('Alt');
      if (hasShift) shortcutParts.push('Shift');

      // Add other keys
      state.keys.forEach(key => {
        if (!['Ctrl', 'Alt', 'Shift', 'Meta', 'Command'].includes(key)) {
          shortcutParts.push(key);
        }
      });

      // Format for Electron
      const shortcutString = shortcutParts.join('+');
      elements.newShortcut.textContent = shortcutString;
    }

    // Show transcript detail in the main content area
    function showTranscriptDetail(item, event) {
      // Update selected state in sidebar
      document.querySelectorAll('.history-item').forEach(el => el.classList.remove('selected'));
      event.currentTarget.classList.add('selected');

      // Update detail view
      const detailView = document.getElementById('selectedTranscript');
      const date = new Date(item.timestamp);

      const processedText = item.processedText || 'Processing failed';
      const canCopyProcessed = item.processedText && item.processedText !== 'Processing failed';

      detailView.innerHTML = `
        <div class="content">
          <div class="transcript-section">
            <h3>Processed Transcript</h3>
            <div class="text">${processedText}</div>
            <div class="transcript-actions">
              <button onclick="copyToClipboard(this, '${encodeURIComponent(canCopyProcessed ? item.processedText : '')}')"
                      class="button-success"
                      ${!canCopyProcessed ? 'disabled' : ''}>
                Copy Processed
              </button>
            </div>
          </div>

          <div class="transcript-section">
            <h3>Raw Transcript</h3>
            <div class="text">${item.rawText}</div>
            <div class="transcript-actions">
              <button onclick="copyToClipboard(this, '${encodeURIComponent(item.rawText)}')" class="button-success">Copy Raw</button>
            </div>
          </div>
        </div>
      `;
    }

    // Load and display history
    async function loadHistory() {
      const history = await window.api.getHistory();
      elements.historyList.innerHTML = '';

      if (history.length === 0) {
        elements.historyList.innerHTML = '<div style="padding: var(--spacing-md); color: var(--secondary-text);">No history items</div>';
        return;
      }

      history.forEach(item => {
        const div = document.createElement('div');
        div.className = 'history-item';
        div.onclick = (event) => showTranscriptDetail(item, event);

        const date = new Date(item.timestamp);
        const preview = item.processedText || item.rawText;

        div.innerHTML = `
          <div class="timestamp">${date.toLocaleString()}</div>
          <div class="preview">${preview.substring(0, 100)}${preview.length > 100 ? '...' : ''}</div>
        `;

        elements.historyList.appendChild(div);
      });
    }

    // Copy text to clipboard with visual feedback
    async function copyToClipboard(button, encodedText) {
      const text = decodeURIComponent(encodedText);
      console.log('Copying text:', text);  // Debug log
      try {
        await navigator.clipboard.writeText(text);
        button.classList.add('copied');

        // Remove the copied state after animation
        setTimeout(() => {
          button.classList.remove('copied');
        }, 1000);
      } catch (err) {
        console.error('Failed to copy text:', err);
      }
    }

    // Save prompt settings
    async function savePromptSettings() {
      try {
        await window.api.setPromptSettings({
          enabled: elements.enablePostProcessing.checked,
          prompt: elements.prompt.value
        });
        showStatus(elements.promptStatus, 'Settings saved successfully', 'success');
      } catch (error) {
        showStatus(elements.promptStatus, `Error saving settings: ${error.message}`, 'error');
      }
    }

    // Load history settings
    async function loadHistorySettings() {
      try {
        const settings = await window.api.getHistorySettings();
        elements.historyEnabled.checked = settings.enabled;

        // Update encryption status
        const isEncrypted = await window.api.isHistoryEncrypted();
        if (isEncrypted) {
          elements.encryptionStatus.innerHTML = '🔒 History is encrypted';
        } else {
          elements.encryptionStatus.innerHTML = '⚠️ History is not encrypted';
        }
      } catch (error) {
        console.error('Error loading history settings:', error);
      }
    }

    /**
     * UI Helpers
     */

    // Show status message
    function showStatus(element, message, type) {
      element.textContent = message;
      element.className = `status ${type}`;
    }

    /**
     * Event Listeners
     */
    function setupEventListeners() {
      // Tab navigation
      const tabButtons = document.querySelectorAll('.tab-button');
      const tabPanels = document.querySelectorAll('.tab-panel');

      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const tabId = button.getAttribute('data-tab');

          // Update active tab button
          tabButtons.forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');

          // Show selected tab panel
          tabPanels.forEach(panel => panel.style.display = 'none');
          document.getElementById(`${tabId}-panel`).style.display = 'block';
        });
      });

      // Provider selection
      elements.apiProvider.addEventListener('change', function() {
        state.apiProvider = this.value;
        window.api.setApiProvider(this.value);
        updateApiSectionVisibility();
      });

      // API Key events
      elements.saveApiKeyBtn.addEventListener('click', saveApiKey);
      elements.saveOpenaiApiKeyBtn.addEventListener('click', saveOpenaiApiKey);

      // Model and URL changes
      elements.groqBaseUrl.addEventListener('change', () => elements.saveApiKeyBtn.click());
      elements.groqModel.addEventListener('change', () => elements.saveApiKeyBtn.click());

      elements.openaiBaseUrl.addEventListener('change', () => elements.saveOpenaiApiKeyBtn.click());
      elements.openaiModel.addEventListener('change', () => elements.saveOpenaiApiKeyBtn.click());

      // Shortcut events
      elements.editShortcut.addEventListener('click', startShortcutListener);
      elements.saveShortcut.addEventListener('click', saveShortcut);
      elements.cancelShortcut.addEventListener('click', cancelShortcutChange);

      // Setup key event listeners for capturing shortcut
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('keyup', handleKeyUp);

      // Post-processing events
      elements.enablePostProcessing.addEventListener('change', () => {
        updatePromptSectionState();
        savePromptSettings();
      });
      elements.prompt.addEventListener('change', savePromptSettings);
      elements.resetPrompt.addEventListener('click', resetPrompt);

      // History events
      elements.historyEnabled.addEventListener('change', toggleHistoryEnabled);
      elements.clearHistory.addEventListener('click', clearHistoryConfirm);

      // Error handling
      window.api.onShortcutError && window.api.onShortcutError((message) => {
        showStatus(elements.shortcutStatus, `Error: ${message}`, 'error');
      });
    }

    // Initialize when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      loadSettings();
      setupEventListeners();

      // Listen for history updates
      window.api.onHistoryUpdate(() => {
        loadHistory();
      });
    });

    // Toggle history enabled setting
    async function toggleHistoryEnabled() {
      try {
        await window.api.setHistoryEnabled(elements.historyEnabled.checked);
        // Reload history if enabled
        if (elements.historyEnabled.checked) {
          await loadHistory();
        } else {
          // Clear display but not actual history
          elements.historyList.innerHTML = '<div style="padding: var(--spacing-md); color: var(--secondary-text);">History is disabled</div>';
        }
      } catch (error) {
        console.error('Error saving history settings:', error);
      }
    }

    // Show confirmation before clearing history
    async function clearHistoryConfirm() {
      if (confirm('Are you sure you want to clear all history? This cannot be undone.')) {
        try {
          await window.api.clearHistory();
          await loadHistory();
        } catch (error) {
          console.error('Error clearing history:', error);
        }
      }
    }
  </script>
</body>

</html>